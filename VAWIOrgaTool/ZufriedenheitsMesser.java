import java.text.DecimalFormat;
import java.util.Iterator;

import AusgabeDatenVerwaltung.DatenObjekte.Pruefungstag;
import AusgabeDatenVerwaltung.Datenverwaltung.Pruefungsterminplan;
import EingabeDatenVerwaltung.DatenObjekte.Buchung;
import EingabeDatenVerwaltung.DatenObjekte.Kurs;
import EingabeDatenVerwaltung.DatenObjekte.Student;
import EingabeDatenVerwaltung.DatenVerwaltung.Buchungsliste;
import EingabeDatenVerwaltung.DatenVerwaltung.Studentenliste;



/**
 * Der ZufriedenheitsMesser ist f&uuml;r die Zufriedenheitsmessung der einzelnen Studenten mit der Planung zust&auml;ndig. <br>
 * Dazu verwendet er den Pruefungsterminplan und die Attribute Zufriedenheit und Zeitminimierer der Studenten der Studentenliste.
 * 
 * @author Markus Bode
 * @version 1.0 vom 6.12.2009
 */
public class ZufriedenheitsMesser {

	private Pruefungsterminplan pruefungsterminplan;
	
	private Studentenliste studentenliste;
	
	private Buchungsliste buchungsliste;

	/**
	 * Der Konstruktor erwartet einen Pruefungsterminplan und eine Studentenliste. <br>
	 * Die Studentenliste enthaelt die gegen den Terminplan zu ueberpruefenden Studenten-Objekte. 
	 * 
	 * @param prfgtpl (Pruefungsterminplan): Von der PruefungsPlanung erstellter PruefungsTerminplan.
	 * @param stdl (Studentenliste): Die Verwaltungsliste mit den Studenten-Objekten.
	 * @param bl (Buchungsliste): Die Verwaltungsliste mit den Buchungs-Objekten.
	 */
	public ZufriedenheitsMesser(Pruefungsterminplan prfgtpl,Studentenliste stdl,Buchungsliste bl){
		//setze Instanzvariablen
		this.pruefungsterminplan=prfgtpl;
		this.studentenliste=stdl;
		this.buchungsliste=bl;
	}
	
	/**
	 * Methode prueft alle Studenten-Objekte in der (im Konstruktor gesetzten) Studentenliste<br>
	 * auf Ihre Zufriedenheit  mit dem erstellten Pruefungsterminplan.<br>
	 * Außschlaggebend ist das Attribut <tt>zeitminimierer</tt>. <br>
	 * Die Zufriedenheit wird dann bei dem Studenten als <tt>boolean</tt> gespeichert.<br>
	 * Wenn Student zeitminimierer ist und er maximal einen Prüfungstag hat: <tt>zufriedenheit==true</tt><br>
	 * Wenn Student kein zeitminimierer ist und er nicht mehr wie 1 Prüfung pro Tag hat: <tt>zufriedenheit==true</tt><br>
	 * Bei allen anderen: <tt>zufriedenheit==false</tt>
	 * 
	 * @return Studentenliste: Liste mit Studentenobjekten die geprüft wurden
	 * 
	 */
	public Studentenliste errechneZufriedenheit(){
		
		//gib null zurück wenn Methode aufgerufen wird ohne gültige Verwaltungslisten 
		if(pruefungsterminplan==null||studentenliste==null||buchungsliste==null){
			System.out.println("Prüfungsterminplan, Studentenliste oder Buchungsliste ist noch null! -> keine Errechnung");
			return null;
		}
		//hole Iterator über alle Studenten
		Iterator<Student> si = studentenliste.getStudentIterator();
		System.out.println("****** Start Zufriedenheitsberechnung.*********");
		System.out.println("----------------------------------------------------");
		System.out.println("Name, Vorname\t\tisZeitminimierer|isZufrieden\nMatrikelNr");
		System.out.println("----------------------------------------------------");
		
		//Anzahl der zufriedenen Studenten
		int anzahlZufrieden = 0;
		
		//Prüfe jeden einzelnen Studenten
		while(si.hasNext()){
			Student student = si.next();
			//Anzahl der Prüfungstage an denen der Student erscheinen muss
			int anzahlPruefungstage = 0;
			
			//maximale Anzahl an Prüfungen pro Tag die der Student an den Prüfungstagen schreiben muss 
			int maxPruefungenProTag = 0;
			
			//Iterator über alle Prüfungstage
			Iterator<Pruefungstag> pi = pruefungsterminplan.getPruefungsplanIterator();
			
			//prüfe jeden Prüfungstag
			while(pi.hasNext()){
				Pruefungstag pruefungstag = pi.next();
				//Studentenliste mit Studenten die an diesem Tag Prüfung schreiben müssen
				Studentenliste sl = pruefungstag.getTagesStudentenliste();
								
				//wenn der Student in der Studentenliste des Tages ist, muss der Tag in die Betrachtung mit einfließen
				//die anzahlPruefungstage erhöht sich und es muss geprüft werden wieviele Kurse der Student an diesem Tag schreibt
				if(sl.containsStudent(student)){
						
						anzahlPruefungstage++;
						
						//Anzahl Kurse die der Student an diesem Tag schreibt
						int kurse = 0;
						
						//alle Buchungen des aktuellen Studenten
						Iterator<Buchung> bi = buchungsliste.getBuchungen(student).getIterator();
						
						//prüfe alle Buchungen des Studenten
						while(bi.hasNext()){
							
							Kurs k = bi.next().getKurs();
							
							//prüfe ob der Kurs des aktuellen Buchungsobjektes in der Tageskursliste enthalten ist
							//wenn ja, dann muss der Zähler für die Kurse die der Student an diesem Tag schreibt erhöht werden
							//(Student muss an diesem Tag zu dieser Prüfung erscheinen)
							if(pruefungstag.getTagesKursliste().containsKurs(k)){
								kurse++;
							}
						}
						
						//prüfe ob die Anzahl der von diesem Student zu schreibenden Kurse an diesem Tag
						//größer ist wie die Anzahl der Kurse die er an den letzten geprüften Tagen schreiben musste
						//--> die maximale Anzahl an zu schreibenden Prüfungen pro Tag aller Prüfungstage wird gespeichert
						if(kurse>maxPruefungenProTag){
							maxPruefungenProTag=kurse;
						}
				
				}
			}
			
			if(student.getZeitminimierer()&&(anzahlPruefungstage==1)){
				// der Zeitminimierer-Student hat nur an einem Prüfungstag zu erscheinen -> er ist zufrieden
				anzahlZufrieden++;
				//setze Zufrieden
				student.setZufrieden(true);
			}else if(!student.getZeitminimierer()&&(maxPruefungenProTag==1)){
			   // der nicht Zeitminimierer-Student schreibt maximal eine Prüfung pro Tag im ganzen Prüfungsterminplan -> er ist zufrieden
				anzahlZufrieden++;
				student.setZufrieden(true);
			}else{
				// mit allen anderen Konstellationen sind die Studenten unzufrieden
				// ..>  zeitminimierer==true && anzahlPruefungstage > 1
				//		zeitminimierer==false && maxPruefungenProTag > 1
				student.setZufrieden(false);
			}
			System.out.println(student.getName()+", "+student.getVorname());
			System.out.println(student.getMatrikelnr()+"\t\t\t"+student.getZeitminimierer()+"\t\t "+student.getZufrieden());
			System.out.println("--------------------------------------------------");
			
		}
	
	System.out.println("Anzahl Studenten: "+studentenliste.getSize()+" Anzahl zufriedene Studenten: "+anzahlZufrieden+ " => "+new DecimalFormat("0.00").format(((double)anzahlZufrieden*100)/studentenliste.getSize())+"%");
		
	return studentenliste;
	}

}
